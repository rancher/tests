name: Platform QA Package Dispatcher

on:
  workflow_dispatch:
    inputs:
      rancher_hosts:
        description: "Comma-separated Rancher hosts. Example: cluster1.qa.rancher.space,cluster2.qa.rancher.space"
        required: true
      admin_tokens:
        description: "Comma-separated Admin API tokens (same order as Rancher hosts)"
        required: true
      cluster_names:
        description: "Comma-separated downstream cluster names (same order as Rancher hosts)"
        required: true
      kubernetes_versions:
        description: "Comma-separated Kubernetes versions (same order as Rancher hosts) Example: v1.31.11+k3s1,v1.32.7+k3s1"
        required: true
      test_packages:
        description: "Comma-separated test package paths (e.g. validation/rbac,validation/projects)"
        required: true
        default: "validation/rbac,validation/projects,validation/auth"
      run_all_tests:
        description: "Run all test files in the package?"
        required: true
        default: "true"
        type: choice
        options: ["true", "false"]
      recursive_tests:
        description: "Recursively find and run tests in sub-packages?"
        required: true
        default: "true"
        type: choice
        options: ["true", "false"]
      test_selector:
        description: "Test suite or test name regex, if run_all_tests=false (e.g. ^TestSuiteName$ or ^TestSuite/TestCase$)"
        required: false
      exclude_test_files:
        description: "Test files to exclude (comma-separated), if run_all_tests=true (e.g. rbac_test.go,projects_test.go)"
        required: false
      qase_test_run_ids:
        description: "Comma-separated Qase test run IDs (same order as Rancher hosts). Leave empty if not reporting to Qase"
        required: false

permissions:
  contents: read
  actions: write

jobs:
  dispatch:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repository
        uses: actions/checkout@08eba0b27e820071cde6df949e0beb9ba4906955  # v4.3.0
        with:
          submodules: recursive

      - name: Mask admin token
        run: echo "::add-mask::$RANCHER_ADMIN_TOKEN"

      - name: Flatten package list (only if recursive)
        id: flatten-pkg
        if: ${{ github.event.inputs.recursive_tests == 'true' }}
        run: |
          INPUT_PKGS="${{ github.event.inputs.test_packages }}"
          FLATTENED=()
          declare -A unique_packages
          
          IFS=',' read -ra PKGS <<< "$INPUT_PKGS"
          for pkg in "${PKGS[@]}"; do
            DIRS=$(find "$pkg" -type f -name '*_test.go' -printf '%h\n' | sort -u)


            if [ -n "$DIRS" ]; then
              while IFS= read -r dir; do
                unique_packages["$dir"]=1
              done <<< "$DIRS"
            fi
          done

          FLAT_LIST=$(IFS=','; echo "${!unique_packages[*]}")
          echo "Flattened list: $FLAT_LIST"
          echo "test_packages=$FLAT_LIST" >> $GITHUB_OUTPUT

      - name: Dispatch package runner workflow for each cluster
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const workflow_id = "platform-qa-package-runner.yml";
            const ref = "main"; 
            const hosts = "${{ github.event.inputs.rancher_hosts }}".split(',').map(s => s.trim());
            const tokens = "${{ github.event.inputs.admin_tokens }}".split(',').map(s => s.trim());
            const clusters = "${{ github.event.inputs.cluster_names }}".split(',').map(s => s.trim());
            const kubernetesVersions = "${{ github.event.inputs.kubernetes_versions }}".split(',').map(s => s.trim());
            const qaseRunsRaw = "${{ github.event.inputs.qase_test_run_ids }}";
            const qaseRuns = qaseRunsRaw ? qaseRunsRaw.split(',').map(s => s.trim()) : [];

            const test_packages = "${{ steps.flatten-pkg.outputs.test_packages || github.event.inputs.test_packages }}";

            if (hosts.length !== tokens.length || tokens.length !== clusters.length) {
              throw new Error("Input lengths for rancher_hosts, admin_tokens, and cluster_names must match");
            }
            if (kubernetesVersions.length !== hosts.length) {
              throw new Error("Kubernetes versions count must match rancher_hosts count");
            }

            for (let i = 0; i < hosts.length; i++) {
              const host = hosts[i];
              const token = tokens[i];
              const cluster = clusters[i];
              const qaseRun = qaseRuns[i] || "";
              const reportToQase = qaseRun !== "" ? "true" : "false";
              const k8sVersion = kubernetesVersions[i] || "";

              console.log(`ðŸš€ Dispatching for host=${host}, cluster=${cluster}, packages=${test_packages}`);

              const inputs = {
                rancher_host: host,
                admin_token: token,
                cluster_name: cluster,
                kubernetes_version: k8sVersion,
                test_packages,
                run_all_tests: "${{ github.event.inputs.run_all_tests }}",
                test_selector: "${{ github.event.inputs.test_selector }}",
                exclude_test_files: "${{ github.event.inputs.exclude_test_files }}",
                qase_test_run_id: qaseRun,
                report_to_qase: reportToQase
              };

              await github.rest.actions.createWorkflowDispatch({
                owner: context.repo.owner,
                repo: context.repo.repo,
                workflow_id,
                ref,
                inputs
              });
            }
