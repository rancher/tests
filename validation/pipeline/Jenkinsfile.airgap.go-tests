#!groovy
// Load qa-jenkins-library dynamically based on parameter
def libraryBranch = env.QA_JENKINS_LIBRARY_BRANCH ?: 'main'
library "qa-jenkins-library@${libraryBranch}"

node {
    def testsPath = './tests'
    def qaInfraPath = './qa-infra-automation'
    def tofuModulePath = "${qaInfraPath}/tofu/aws/modules/airgap"
    def tofuBackendInitScript = './scripts/init-backend.sh'
    def ansiblePath = "${qaInfraPath}/ansible/rke2/airgap"
    def workspaceName = ''
    def rancherHostname = ''

    def testsBranch = env.GO_REPO_BRANCH ?: 'main'
    def testsRepo = env.GO_REPO_URL ?: 'https://github.com/rancher/tests'
    def qaInfraBranch = env.QA_INFRA_REPO_BRANCH ?: 'main'
    def qaInfraRepo = env.QA_INFRA_REPO_URL ?: 'https://github.com/rancher/qa-infra-automation'

    def goTestPackage = env.GO_TEST_PACKAGE?.trim() ?: './validation/...'
    def goTestCase = env.GO_TEST_CASE ?: ''
    def goTags = env.GO_TAGS ?: 'validation'
    def goTimeout = env.GO_TIMEOUT ?: '45m'
    def cattleTestConfig = env.CATTLE_TEST_CONFIG ?: ''
    def reportArtifacts = (env.REPORT_ARTIFACTS ?: 'true').toBoolean()

    // Optional: always destroy infra at end
    def destroyAfterTests = (env.DESTROY_AFTER_TESTS ?: 'true').toBoolean()

    property.useWithProperties(['AWS_ACCESS_KEY_ID', 'AWS_SECRET_ACCESS_KEY', 'AWS_SSH_PEM_KEY', 'AWS_SSH_PEM_KEY_NAME']) {
        try {
            stage('Checkout') {
                deleteDir()

                // Set build display name + description for quick identification
                def hostnamePrefix = env.HOSTNAME_PREFIX ?: 'unknown'
                currentBuild.displayName = "#${env.BUILD_NUMBER} - ${hostnamePrefix}"
                currentBuild.description = "Deploying airgap infrastructure for ${hostnamePrefix}"

                echo 'Cloning tests repository'
                checkout([
                    $class: 'GitSCM',
                    branches: [[name: "*/${testsBranch}"]],
                    extensions: scm.extensions + [
                        [$class: 'CleanCheckout'],
                        [$class: 'RelativeTargetDirectory', relativeTargetDir: 'tests']
                    ],
                    userRemoteConfigs: [[url: testsRepo]]
                ])

                echo 'Cloning qa-infra-automation repository'
                checkout([
                    $class: 'GitSCM',
                    branches: [[name: "*/${qaInfraBranch}"]],
                    extensions: scm.extensions + [
                        [$class: 'CleanCheckout'],
                        [$class: 'RelativeTargetDirectory', relativeTargetDir: 'qa-infra-automation']
                    ],
                    userRemoteConfigs: [[url: qaInfraRepo]]
                ])
            }

            stage('Build Infrastructure Tools Image') {
                echo 'Building Docker image with Tofu, Ansible, Go toolchain, and gotestsum'
                sh "docker build --platform linux/amd64 -t rancher-infra-tools:latest -f ${testsPath}/validation/pipeline/Dockerfile.airgap-go-tests ."
            }

            stage('Configure SSH Key') {
                infrastructure.writeSshKey(
                    keyContent: env.AWS_SSH_PEM_KEY,
                    keyName: env.AWS_SSH_PEM_KEY_NAME,
                    dir: '.ssh'
                )
            }

            stage('Configure Tofu Variables') {
                echo 'Writing Terraform configuration'

                def terraformConfig = infrastructure.parseAndSubstituteVars(
                    content: env.TERRAFORM_CONFIG,
                    envVars: [
                        'AWS_ACCESS_KEY_ID': env.AWS_ACCESS_KEY_ID,
                        'AWS_SECRET_ACCESS_KEY': env.AWS_SECRET_ACCESS_KEY,
                        'HOSTNAME_PREFIX': env.HOSTNAME_PREFIX,
                        'AWS_SSH_PEM_KEY_NAME': env.AWS_SSH_PEM_KEY_NAME
                    ]
                )

                infrastructure.writeConfig(
                    path: "${tofuModulePath}/terraform.tfvars",
                    content: terraformConfig
                )
            }

            stage('Initialize Tofu Backend') {
                tofu.initBackend(
                    dir: tofuModulePath,
                    bucket: env.S3_BUCKET_NAME,
                    key: env.S3_KEY_PREFIX,
                    region: env.S3_BUCKET_REGION,
                    backendInitScript: tofuBackendInitScript
                )
            }

            stage('Create Workspace') {
                workspaceName = infrastructure.generateWorkspaceName(
                    prefix: 'jenkins_airgap_ansible_workspace',
                    suffix: env.HOSTNAME_PREFIX,
                    includeTimestamp: false
                )

                tofu.createWorkspace(
                    dir: tofuModulePath,
                    name: workspaceName
                )

                infrastructure.archiveWorkspaceName(
                    workspaceName: workspaceName
                )
            }

            stage('Apply Tofu') {
                tofu.apply(
                    dir: tofuModulePath,
                    varFile: 'terraform.tfvars',
                    autoApprove: true
                )

                // Archive generated inventory file
                def inventoryPath = 'qa-infra-automation/ansible/rke2/airgap/inventory/inventory.yml'
                if (fileExists(inventoryPath)) {
                    archiveArtifacts artifacts: inventoryPath, fingerprint: true
                    echo "Archived inventory file: ${inventoryPath}"
                } else {
                    echo "Warning: Inventory file not found at ${inventoryPath}"
                }

                // Upload tfvars to S3 (for destroy job reference)
                def s3Path = "env:/${workspaceName}/terraform.tfvars"
                def tfvarsPath = "${tofuModulePath}/terraform.tfvars"
                def workspace = pwd()
                sh """
                    docker run --rm --platform linux/amd64 \
                        -e AWS_ACCESS_KEY_ID=${env.AWS_ACCESS_KEY_ID} \
                        -e AWS_SECRET_ACCESS_KEY=${env.AWS_SECRET_ACCESS_KEY} \
                        -v ${workspace}:/workspace \
                        -w /workspace \
                        rancher-infra-tools:latest \
                        sh -c 'aws s3 cp ${tfvarsPath} s3://${env.S3_BUCKET_NAME}/${s3Path} --region ${env.S3_BUCKET_REGION}'
                """
                echo "Uploaded terraform.tfvars to s3://${env.S3_BUCKET_NAME}/${s3Path}"
            }

            stage('Configure Ansible Variables') {
                echo 'Writing Ansible variables'

                def ansibleVars = infrastructure.parseAndSubstituteVars(
                    content: env.ANSIBLE_VARIABLES,
                    envVars: [
                        'RKE2_VERSION': env.RKE2_VERSION,
                        'RANCHER_VERSION': env.RANCHER_VERSION,
                        'HOSTNAME_PREFIX': env.HOSTNAME_PREFIX,
                        'PRIVATE_REGISTRY_URL': env.PRIVATE_REGISTRY_URL ?: '',
                        'PRIVATE_REGISTRY_USERNAME': env.PRIVATE_REGISTRY_USERNAME ?: '',
                        'PRIVATE_REGISTRY_PASSWORD': env.PRIVATE_REGISTRY_PASSWORD ?: ''
                    ]
                )

                def sshKeyPath = "/root/.ssh/${env.AWS_SSH_PEM_KEY_NAME}"
                if (!ansibleVars.contains('ssh_private_key_file:')) {
                    ansibleVars += "\nssh_private_key_file: ${sshKeyPath}"
                }

                ansible.writeInventoryVars(
                    path: "${ansiblePath}/inventory/group_vars/all.yml",
                    content: ansibleVars
                )
            }

            stage('Setup SSH Keys on Nodes') {
                ansible.runPlaybook(
                    dir: ansiblePath,
                    inventory: 'inventory/inventory.yml',
                    playbook: 'playbooks/setup/setup-ssh-keys.yml'
                )
            }

            stage('Deploy RKE2 Cluster') {
                ansible.runPlaybook(
                    dir: ansiblePath,
                    inventory: 'inventory/inventory.yml',
                    playbook: 'playbooks/deploy/rke2-tarball-playbook.yml'
                )
            }

            stage('Deploy Rancher (Optional)') {
                def deployRancher = env.ANSIBLE_VARIABLES?.contains('deploy_rancher: true')
                if (deployRancher) {
                    echo 'Deploying Rancher...'
                    ansible.runPlaybook(
                        dir: ansiblePath,
                        inventory: 'inventory/inventory.yml',
                        playbook: 'playbooks/deploy/rancher-helm-deploy-playbook.yml'
                    )
                } else {
                    echo 'Skipping Rancher deployment (not enabled in ANSIBLE_VARIABLES)'
                }
            }

            stage('Resolve Outputs') {
                try {
                    rancherHostname = tofu.getOutputs(
                        dir: tofuModulePath,
                        output: 'external_lb_hostname'
                    )
                    echo "Rancher Hostname (External): ${rancherHostname}"
                    currentBuild.description = "Deployed: https://${rancherHostname} | Workspace: ${workspaceName}"
                } catch (e) {
                    echo "Could not retrieve external LB hostname: ${e.message}"
                }

                try {
                    def internalLbHostname = tofu.getOutputs(
                        dir: tofuModulePath,
                        output: 'internal_lb_hostname'
                    )
                    echo "Internal LB Hostname: ${internalLbHostname}"
                } catch (e) {
                    echo "Could not retrieve internal LB hostname: ${e.message}"
                }
            }

            stage('Run Go Automation Tests') {
                echo 'Running Go tests with gotestsum (JUnit output)'

                // Prepare env-file for docker run
                def envFile = '.go_test_env'
                def lines = []
                // Provide common test env vars
                if (rancherHostname) {
                    lines += [
                        "RANCHER_URL=https://${rancherHostname}",
                        "RANCHER_HOSTNAME=${rancherHostname}",
                    ]
                }
                // If Ansible variables defined a bootstrap password, default commonly used value
                lines += ["RANCHER_BOOTSTRAP_PASSWORD=${env.RANCHER_BOOTSTRAP_PASSWORD ?: 'rancherrocks'}"]

                // Optional inline cattle test config
                if (cattleTestConfig?.trim()) {
                    def cattleConfigPath = "${testsPath}/cattle-config.yaml"
                    writeFile file: cattleConfigPath, text: cattleTestConfig.trim() + '\n'
                    lines += 'CATTLE_TEST_CONFIG=/workspace/tests/cattle-config.yaml'
                }

                def envContent = lines.findAll { it?.trim() }.join('\n')
                writeFile file: envFile, text: envContent ? envContent + '\n' : ''

                def workspace = pwd()
                def junitPath = 'junit.xml'
                def goArgs = "-timeout ${goTimeout} -tags \"${goTags}\" ${goTestPackage}"
                if (goTestCase?.trim()) {
                    goArgs += " ${goTestCase.trim()}"
                }

                def testCmd = "gotestsum --junitfile ${junitPath} -- ${goArgs}"

                // Run tests with gotestsum (preinstalled)
                sh """
                    docker run --rm --platform linux/amd64 \
                        --env-file ${envFile} \
                        -v ${workspace}:/workspace \
                        -w /workspace/tests \
                        rancher-infra-tools:latest \
                        sh -c 'set -e; set -o pipefail; echo "Running: ${testCmd}"; ${testCmd} | tee go-test.log'
                """

                // Publish results
                catchError(buildResult: 'FAILURE', stageResult: 'FAILURE') {
                    junit allowEmptyResults: true, testResults: junitPath
                }

                if (reportArtifacts) {
                    archiveArtifacts allowEmptyArchive: true, artifacts: "go-test.log, ${junitPath}", fingerprint: true
                }
            }
        } catch (err) {
            currentBuild.result = 'FAILURE'
            echo "Build failed: ${err.message}"

            if ((env.DESTROY_ON_FAILURE ?: 'true').toBoolean() && workspaceName) {
                echo 'DESTROY_ON_FAILURE is enabled. Cleaning up infrastructure...'
                try {
                    stage('Cleanup on Failure') {
                        tofu.selectWorkspace(dir: tofuModulePath, name: workspaceName)
                        tofu.destroy(dir: tofuModulePath, varFile: 'terraform.tfvars', autoApprove: true)
                        tofu.deleteWorkspace(dir: tofuModulePath, name: workspaceName)
                    }
                } catch (cleanupErr) {
                    echo "Cleanup failed: ${cleanupErr.message}"
                }
            }
            throw err
        } finally {
            if (destroyAfterTests && workspaceName) {
                echo 'Destroying infrastructure after tests (configured)'
                try {
                    stage('Destroy After Tests') {
                        tofu.selectWorkspace(dir: tofuModulePath, name: workspaceName)
                        tofu.destroy(dir: tofuModulePath, varFile: 'terraform.tfvars', autoApprove: true)
                        tofu.deleteWorkspace(dir: tofuModulePath, name: workspaceName)
                    }
                } catch (cleanupErr) {
                    echo "Destroy-after-tests failed: ${cleanupErr.message}"
                }
            }
        }
    }
}
