#!groovy
// Load qa-jenkins-library dynamically based on parameter
def libraryBranch = env.QA_JENKINS_LIBRARY_BRANCH ?: 'main'
library "qa-jenkins-library@${libraryBranch}"

node {
    def testsPath = './tests'
    def qaInfraPath = './qa-infra-automation'
    def tofuModulePath = "${qaInfraPath}/tofu/aws/modules/airgap"
    def tofuBackendInitScript = './scripts/init-backend.sh'
    def ansiblePath = "${qaInfraPath}/ansible/rke2/airgap"
    def workspaceName = ''
    def rancherHostname = ''
    def dockerPlatform = config.getDockerPlatform()
    def infraToolsImage = config.getDockerImage('infraTools')
    def infrastructureCleaned = false

    def testsBranch = env.RANCHER_TEST_REPO_BRANCH ?: 'main'
    def testsRepo = env.RANCHER_TEST_REPO_URL ?: 'https://github.com/rancher/tests'
    def qaInfraBranch = env.QA_INFRA_REPO_BRANCH ?: 'main'
    def qaInfraRepo = env.QA_INFRA_REPO_URL ?: 'https://github.com/rancher/qa-infra-automation'

    def goTestPackage = env.GO_TEST_PACKAGE?.trim() ?: './validation/...'
    def goTestCase = env.GO_TEST_CASE ?: ''
    def goTags = env.GO_TAGS ?: 'validation'
    def goTimeout = env.GO_TIMEOUT ?: '45m'
    def cattleTestConfig = env.CATTLE_TEST_CONFIG ?: ''
    def reportArtifacts = (env.REPORT_ARTIFACTS ?: 'true').toBoolean()

    // Optional: always destroy infra at end
    def destroyAfterTests = (env.DESTROY_AFTER_TESTS ?: 'true').toBoolean()

    // Qase test reporting configuration
    def qaseTestRunId = env.QASE_TEST_RUN_ID ?: ''
    def qaseProjectId = env.QASE_PROJECT_ID ?: ''
    def qaseReporterScript = env.QASE_REPORTER_SCRIPT ?: 'build_qase_reporter_v2.sh'

    property.useWithProperties(['AWS_ACCESS_KEY_ID', 'AWS_SECRET_ACCESS_KEY', 'AWS_SSH_PEM_KEY', 'AWS_SSH_PEM_KEY_NAME']) {
        try {
            stage('Checkout') {
                deleteDir()

                // Set build display name + description for quick identification
                def hostnamePrefix = env.HOSTNAME_PREFIX ?: 'unknown'
                currentBuild.displayName = "#${env.BUILD_NUMBER} - ${hostnamePrefix}"
                currentBuild.description = "Deploying airgap infrastructure for ${hostnamePrefix}"

                echo 'Cloning tests repository'
                checkout([
                    $class: 'GitSCM',
                    branches: [[name: "*/${testsBranch}"]],
                    extensions: scm.extensions + [
                        [$class: 'CleanCheckout'],
                        [$class: 'RelativeTargetDirectory', relativeTargetDir: 'tests']
                    ],
                    userRemoteConfigs: [[url: testsRepo]]
                ])

                echo 'Cloning qa-infra-automation repository'
                checkout([
                    $class: 'GitSCM',
                    branches: [[name: "*/${qaInfraBranch}"]],
                    extensions: scm.extensions + [
                        [$class: 'CleanCheckout'],
                        [$class: 'RelativeTargetDirectory', relativeTargetDir: 'qa-infra-automation']
                    ],
                    userRemoteConfigs: [[url: qaInfraRepo]]
                ])
            }

            stage('Build Infrastructure Tools Image') {
                echo 'Building Docker image with Tofu, Ansible, Go toolchain, and gotestsum'
                sh "docker rmi -f ${infraToolsImage} || true"
                sh "docker build --no-cache --platform linux/amd64 -t ${infraToolsImage} -f ${testsPath}/validation/pipeline/Dockerfile.airgap-go-tests ."
            }

            stage('Verify Infra Tools Tooling') {
                echo 'Verifying gotestsum availability inside infra tools image'
                sh """
                    docker run --rm --platform ${dockerPlatform} \
                        ${infraToolsImage} \
                        sh -c 'set -e; echo \"PATH=[1m$PATH\"; which gotestsum || true; ls -al /root/go/bin || true; ls -al /usr/local/bin/gotestsum || true'
                """
            }

            stage('Configure SSH Key') {
                infrastructure.writeSshKey(
                    keyContent: env.AWS_SSH_PEM_KEY,
                    keyName: env.AWS_SSH_PEM_KEY_NAME,
                    dir: '.ssh'
                )
            }

            stage('Configure Tofu Variables') {
                echo 'Writing Terraform configuration'

                def terraformConfig = infrastructure.parseAndSubstituteVars(
                    content: env.TERRAFORM_CONFIG,
                    envVars: [
                        'AWS_ACCESS_KEY_ID': env.AWS_ACCESS_KEY_ID,
                        'AWS_SECRET_ACCESS_KEY': env.AWS_SECRET_ACCESS_KEY,
                        'HOSTNAME_PREFIX': env.HOSTNAME_PREFIX,
                        'AWS_SSH_PEM_KEY_NAME': env.AWS_SSH_PEM_KEY_NAME
                    ]
                )

                infrastructure.writeConfig(
                    path: "${tofuModulePath}/terraform.tfvars",
                    content: terraformConfig
                )
            }

            stage('Initialize Tofu Backend') {
                tofu.initBackend(
                    dir: tofuModulePath,
                    bucket: env.S3_BUCKET_NAME,
                    key: env.S3_KEY_PREFIX,
                    region: env.S3_BUCKET_REGION,
                    backendInitScript: tofuBackendInitScript
                )
            }

            stage('Create Workspace') {
                workspaceName = infrastructure.generateWorkspaceName(
                    prefix: 'jenkins_airgap_ansible_workspace',
                    suffix: env.HOSTNAME_PREFIX,
                    includeTimestamp: false
                )

                tofu.createWorkspace(
                    dir: tofuModulePath,
                    name: workspaceName
                )

                infrastructure.archiveWorkspaceName(
                    workspaceName: workspaceName
                )
            }

            stage('Apply Tofu') {
                tofu.apply(
                    dir: tofuModulePath,
                    varFile: 'terraform.tfvars',
                    autoApprove: true
                )

                // Archive generated inventory file
                def inventoryPath = 'qa-infra-automation/ansible/rke2/airgap/inventory/inventory.yml'
                if (fileExists(inventoryPath)) {
                    archiveArtifacts artifacts: inventoryPath, fingerprint: true
                    echo "Archived inventory file: ${inventoryPath}"
                } else {
                    echo "Warning: Inventory file not found at ${inventoryPath}"
                }

                // Upload tfvars to S3 (for destroy job reference)
                def s3Path = "env:/${workspaceName}/terraform.tfvars"
                def tfvarsPath = "${tofuModulePath}/terraform.tfvars"
                def workspace = pwd()
                sh """
                    docker run --rm --platform linux/amd64 \
                        -e AWS_ACCESS_KEY_ID=${env.AWS_ACCESS_KEY_ID} \
                        -e AWS_SECRET_ACCESS_KEY=${env.AWS_SECRET_ACCESS_KEY} \
                        -v ${workspace}:/workspace \
                        -w /workspace \
                        ${infraToolsImage} \
                        sh -c 'aws s3 cp ${tfvarsPath} s3://${env.S3_BUCKET_NAME}/${s3Path} --region ${env.S3_BUCKET_REGION}'
                """
                echo "Uploaded terraform.tfvars to s3://${env.S3_BUCKET_NAME}/${s3Path}"
            }

            stage('Configure Ansible Variables') {
                echo 'Writing Ansible variables'

                def ansibleVars = infrastructure.parseAndSubstituteVars(
                    content: env.ANSIBLE_VARIABLES,
                    envVars: [
                        'RKE2_VERSION': env.RKE2_VERSION,
                        'RANCHER_VERSION': env.RANCHER_VERSION,
                        'HOSTNAME_PREFIX': env.HOSTNAME_PREFIX,
                        'PRIVATE_REGISTRY_URL': env.PRIVATE_REGISTRY_URL ?: '',
                        'PRIVATE_REGISTRY_USERNAME': env.PRIVATE_REGISTRY_USERNAME ?: '',
                        'PRIVATE_REGISTRY_PASSWORD': env.PRIVATE_REGISTRY_PASSWORD ?: ''
                    ]
                )

                def sshKeyPath = "/root/.ssh/${env.AWS_SSH_PEM_KEY_NAME}"
                if (!ansibleVars.contains('ssh_private_key_file:')) {
                    ansibleVars += "\nssh_private_key_file: ${sshKeyPath}"
                }

                ansible.writeInventoryVars(
                    path: "${ansiblePath}/inventory/group_vars/all.yml",
                    content: ansibleVars
                )
            }

            stage('Setup SSH Keys on Nodes') {
                retry(3) {
                    ansible.runPlaybook(
                        dir: ansiblePath,
                        inventory: 'inventory/inventory.yml',
                        playbook: 'playbooks/setup/setup-ssh-keys.yml'
                    )
                }
            }

            stage('Deploy RKE2 Cluster') {
                retry(3) {
                    ansible.runPlaybook(
                        dir: ansiblePath,
                        inventory: 'inventory/inventory.yml',
                        playbook: 'playbooks/deploy/rke2-tarball-playbook.yml'
                    )
                }
            }

            stage('Deploy Rancher (Optional)') {
                def deployRancher = env.ANSIBLE_VARIABLES?.contains('deploy_rancher: true')
                if (deployRancher) {
                    echo 'Deploying Rancher...'
                    retry(3) {
                        ansible.runPlaybook(
                            dir: ansiblePath,
                            inventory: 'inventory/inventory.yml',
                            playbook: 'playbooks/deploy/rancher-helm-deploy-playbook.yml'
                        )
                    }
                } else {
                    echo 'Skipping Rancher deployment (not enabled in ANSIBLE_VARIABLES)'
                }
            }

            stage('Create Test Config') {
                echo 'Creating test config file if needed'
                if (cattleTestConfig?.trim()) {
                    def cattleConfigPath = "${testsPath}/cattle-config.yaml"
                    writeFile file: cattleConfigPath, text: cattleTestConfig.trim() + '\n'
                    echo "Created test config file: ${cattleConfigPath}"
                } else {
                    echo 'No CATTLE_TEST_CONFIG provided, skipping config creation'
                }
            }

            stage('Resolve Outputs') {
                try {
                    rancherHostname = tofu.getOutputs(
                        dir: tofuModulePath,
                        output: 'external_lb_hostname'
                    )
                    echo "Rancher Hostname (External): ${rancherHostname}"
                    currentBuild.description = "Deployed: https://${rancherHostname} | Workspace: ${workspaceName}"
                } catch (e) {
                    echo "Could not retrieve external LB hostname: ${e.message}"
                }

                try {
                    def internalLbHostname = tofu.getOutputs(
                        dir: tofuModulePath,
                        output: 'internal_lb_hostname'
                    )
                    echo "Internal LB Hostname: ${internalLbHostname}"
                } catch (e) {
                    echo "Could not retrieve internal LB hostname: ${e.message}"
                }
            }

            stage('Inject Admin Token') {
                echo 'Generating admin token via Ansible playbook and injecting into cattle-config.yaml'

                def adminPassword = env.RANCHER_BOOTSTRAP_PASSWORD ?: 'rancherrocks'
                def cattleConfigPath = '/workspace/tests/cattle-config.yaml'
                def workspace = pwd()

                // Token configuration options (can be overridden via environment variables)
                def tokenTtl = env.RANCHER_TOKEN_TTL ?: '0'  // 0 = no expiration
                def tokenDescription = env.RANCHER_TOKEN_DESCRIPTION ?: "jenkins-airgap-${env.BUILD_NUMBER}"

                // Run the Ansible playbook that uses the rancher_token role
                // The rancher_token role:
                // - Reads external_lb_hostname from inventory (or uses explicit rancher_url)
                // - Authenticates with Rancher API
                // - Creates an API token with configurable TTL and description
                // - Updates cattle-config.yaml with the generated token
                sh """
                    docker run --rm --platform ${dockerPlatform} \
                        --name generate-token \
                        -v ${workspace}:/workspace \
                        -w /workspace/${ansiblePath} \
                        ${infraToolsImage} \
                        ansible-playbook -i inventory/inventory.yml playbooks/token/generate-admin-token.yml \
                            -e rancher_token_password=${adminPassword} \
                            -e rancher_cattle_config_file=${cattleConfigPath} \
                            -e rancher_token_ttl=${tokenTtl} \
                            -e rancher_token_description=${tokenDescription} \
                            -e rancher_token_output_format=json \
                            -e rancher_token_output_file=/workspace/rancher-token.json
                """

                // Archive the token metadata (JSON format) for debugging/auditing
                // WARNING: This file contains the full admin API token. Ensure Jenkins artifact
                // access is restricted and consider rotating this token after test completion.
                // Archived to enable manual test reruns in the deployed environment.
                if (fileExists('rancher-token.json')) {
                    archiveArtifacts artifacts: 'rancher-token.json', fingerprint: true
                    echo 'Archived token metadata: rancher-token.json (contains sensitive credentials)'
                }
            }

            stage('Run Go Automation Tests') {
                echo 'Running Go tests with gotestsum (JUnit output)'

                // Prepare env-file for docker run
                def envFile = '.go_test_env'
                def lines = []
                // Provide common test env vars
                if (rancherHostname) {
                    lines += [
                        "RANCHER_URL=https://${rancherHostname}",
                        "RANCHER_HOSTNAME=${rancherHostname}",
                    ]
                }
                // If Ansible variables defined a bootstrap password, default commonly used value
                lines += ["RANCHER_BOOTSTRAP_PASSWORD=${env.RANCHER_BOOTSTRAP_PASSWORD ?: 'rancherrocks'}"]

                // Point to the cattle config file (already created and token-injected in earlier stages)
                // NOTE: Do NOT overwrite the file here - it already has the admin token injected
                def cattleConfigPath = "${testsPath}/cattle-config.yaml"
                if (fileExists(cattleConfigPath)) {
                    lines += 'CATTLE_TEST_CONFIG=/workspace/tests/cattle-config.yaml'
                    echo "Using existing cattle config with injected token: ${cattleConfigPath}"
                } else if (cattleTestConfig?.trim()) {
                    // Fallback: create config if it doesn't exist (should not happen in normal flow)
                    writeFile file: cattleConfigPath, text: cattleTestConfig.trim() + '\n'
                    lines += 'CATTLE_TEST_CONFIG=/workspace/tests/cattle-config.yaml'
                    echo "Warning: Created cattle config without token injection"
                }

                def envContent = lines.findAll { it?.trim() }.join('\n')
                writeFile file: envFile, text: envContent ? envContent + '\n' : ''

                def workspace = pwd()
                def names = generate.names()
                def containerName = names.container

                def testCases = goTestCase?.trim() ? goTestCase.trim() : goTestPackage
                def (testArgs, testConfig) = container._goTestCommand([
                    packages: goTestPackage,
                    cases: testCases,
                    tags: goTags,
                    timeout: goTimeout,
                    resultsXML: 'junit.xml',
                    resultsJSON: 'gotestsum.json'
                ])

                if (testArgs && testArgs[-1]?.endsWith(';')) {
                    testArgs[-1] = testArgs[-1].substring(0, testArgs[-1].length() - 1)
                }

                def testCmd = testArgs.join(' ')
                echo "Running: ${testCmd}"

                sh """
                    docker run --rm --platform ${dockerPlatform} \
                        --name ${containerName} \
                        --env-file ${envFile} \
                        -v ${workspace}:/workspace \
                        -w /workspace/tests \
                        ${infraToolsImage} \
                        sh -c 'set -e; set -o pipefail; ${testCmd} | tee go-test.log'
                """

                // Publish results
                catchError(buildResult: 'FAILURE', stageResult: 'FAILURE') {
                    junit allowEmptyResults: true, testResults: testConfig.resultsXML
                }

                if (reportArtifacts) {
                    archiveArtifacts allowEmptyArchive: true, artifacts: "go-test.log, ${testConfig.resultsXML}, ${testConfig.resultsJSON}", fingerprint: true
                }
            }

            stage('Report to Qase') {
                // Skip if Qase is not configured
                if (!qaseTestRunId?.trim() || !qaseProjectId?.trim()) {
                    echo 'Skipping Qase reporting: QASE_TEST_RUN_ID or QASE_PROJECT_ID not provided'
                    return
                }

                if (!env.QASE_AUTOMATION_TOKEN?.trim()) {
                    echo 'Skipping Qase reporting: QASE_AUTOMATION_TOKEN credential not available'
                    return
                }

                echo "Reporting test results to Qase (Project: ${qaseProjectId}, Run: ${qaseTestRunId})"

                def workspace = pwd()

                // Build and run the Qase reporter
                // The reporter script builds a Go binary that reads test results and uploads to Qase API
                sh """
                    docker run --rm --platform ${dockerPlatform} \
                        --name qase-reporter \
                        -e QASE_TEST_RUN_ID=${qaseTestRunId} \
                        -e QASE_PROJECT_ID=${qaseProjectId} \
                        -e QASE_AUTOMATION_TOKEN=${env.QASE_AUTOMATION_TOKEN} \
                        -v ${workspace}:/workspace \
                        -w /workspace/tests \
                        ${infraToolsImage} \
                        sh -c '
                            set -e
                            echo "Building Qase reporter..."
                            ./validation/pipeline/scripts/${qaseReporterScript}

                            if [ -f ./validation/reporter ]; then
                                echo "Running Qase reporter..."
                                ./validation/reporter
                                echo "Qase reporting complete"
                            else
                                echo "Reporter binary not found - reporter script may have skipped build"
                            fi
                        '
                """

                echo "Test results reported to Qase successfully"
            }
        } catch (err) {
            currentBuild.result = 'FAILURE'
            echo "Build failed: ${err.message}"

            if ((env.DESTROY_ON_FAILURE ?: 'true').toBoolean() && workspaceName && !infrastructureCleaned) {
                echo 'DESTROY_ON_FAILURE is enabled. Cleaning up infrastructure...'
                try {
                    stage('Cleanup on Failure') {
                        tofu.selectWorkspace(dir: tofuModulePath, name: workspaceName)
                        tofu.destroy(dir: tofuModulePath, varFile: 'terraform.tfvars', autoApprove: true)
                        tofu.deleteWorkspace(dir: tofuModulePath, name: workspaceName)
                        infrastructureCleaned = true
                    }
                } catch (cleanupErr) {
                    echo "Cleanup failed: ${cleanupErr.message}"
                }
            }
            throw err
        } finally {
            if (destroyAfterTests && workspaceName && !infrastructureCleaned) {
                echo 'Destroying infrastructure after tests (configured)'
                try {
                    stage('Destroy After Tests') {
                        tofu.selectWorkspace(dir: tofuModulePath, name: workspaceName)
                        tofu.destroy(dir: tofuModulePath, varFile: 'terraform.tfvars', autoApprove: true)
                        tofu.deleteWorkspace(dir: tofuModulePath, name: workspaceName)
                        infrastructureCleaned = true
                    }
                } catch (cleanupErr) {
                    echo "Destroy-after-tests failed: ${cleanupErr.message}"
                }
            } else if (infrastructureCleaned) {
                echo 'Infrastructure already cleaned up, skipping destroy-after-tests'
            }
        }
    }
}
